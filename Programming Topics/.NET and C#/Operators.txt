Instead of setting a type as nullable with ?, you can do the opposite and set non-nullable types with !.

	string! nonNullableString;

////////////////////////////////////////////////////////////////////////////////////

The ?? operator is called the null coalescing operator. 

            Entity result = _repo.GetById(id);

            return result ?? new Entity() { Name = "unknown" };

It is right-associative, so "a ?? b ?? c" is evaluated as "a ?? (b ?? c)"

////////////////////////////////////////////////////////////////////////////////////

The unary postfix "!" operator is the null-forgiving, or null-suppression, operator.

[TestMethod, ExpectedException(typeof(ArgumentNullException))]
public void NullNameShouldThrowTest()
{
    var person = new Person(null!);
}

////////////////////////////////////////////////////////////////////////////////////

Use () to invoke a delegate, like a method.

Action<int> display = s => Console.WriteLine(s);

var numbers = new List<int>();
numbers.Add(10);
numbers.Add(17);
display(numbers.Count);   // output: 2

numbers.Clear();
display(numbers.Count);   // output: 0

////////////////////////////////////////////////////////////////////////////////////

Tidy usage of increment/decrement operators:

// basic stack push method:
public void Push(double item)
{
    _currentIndex++;
    _items[currentIndex] = item;
}

// shortened, but with the ++ increment operator placed BEFORE the variable or you will push to the wrong index:
public void Push(double item)
{
    _items[++currentIndex] = item;
}

// similarly shortened Pop method with an expression body, with the decrement operator placed after the variable:
public double Pop() => _items[_currentIndex--]
